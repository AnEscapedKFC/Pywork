# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'amain.ui'
# Created by: PyQt5 UI code generator 5.15.10
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QDialog
from PyQt5.QtWidgets import (QDesktopWidget, QApplication, QMainWindow, QDialog, QLabel, QLineEdit, QPushButton,\
QTableWidget,QVBoxLayout, QTextBrowser, QMessageBox, QFileDialog, QRadioButton, QTableWidgetItem,QDialogButtonBox,
                             QInputDialog,QHBoxLayout)
import datetime
from PyQt5 import QtCore, QtGui, QtWidgets, QtCore, QtGui
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTextEdit
import CryptTest
import os
import requests

import pymysql
from web3 import Web3
from Compare import *
import ipfshttpclient
import SmartContract1
import all1
global savepath
import json
From = Web3.to_checksum_address("0xe524ae3543aef64ff3fbfcaf2419408888ca6153")######################填写from地址
trade_address = Web3.to_checksum_address("0xceda3e89f8aabce9ac46a5b84601da3a94d80a2f")######################填写Contract地址
url = "http://127.0.0.1:7545"  # Ganache地址，默认7545
username = None
username_g = None


def connect_to_database(): # 连接本地数据库
    global datapassword
    global database
    connection = pymysql.connect(
        host='127.0.0.1', user='root', password='1234', database='db_5'  # 建立数据库连接(4号数据库·)
    )
    return connection



def new_goods(owner,size,good_hash,price, name,id, pkey_hash, MerkleTree_hash, key_hash,  Key_Word = "none", isForsale = "yes"): # 上架新的商品
    connection = connect_to_database()
    cursor = connection.cursor()  # 创建数据库游标
    Time = datetime.datetime.now()  # 获取当前的时间
    try:
        # 执行 SQL 插入操作
        sql = "INSERT INTO goods_information (owner, size, time, good_hash, price, id, pkey_hash, MerkleTree_hash, key_hash, Key_Word, isForsale, name) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
        cursor.execute(sql, (owner, size, Time, good_hash, price, id, pkey_hash, MerkleTree_hash, key_hash, Key_Word, isForsale, name))
        connection.commit()  # 提交事务
        print("商品成功上架！")
    except Exception as e:
        print("插入商品时出现错误:", e)
        connection.rollback()  # 回滚事务，撤销之前的操作
    cursor.close()
    connection.close()



def new_transcations(seller, buyer, name, price, traehash):  # 更新交易记录
    Time = datetime.datetime.now()  # 获取当前的时间
    connection = connect_to_database()
    cursor = connection.cursor()
    try:
        sql = "INSERT INTO transcation (seller, buyer, good_name, time, price, tradehash) VALUES (%s, %s, %s, %s, %s, %s)"
        cursor.execute(sql, (seller, buyer, name, Time, price, traehash))
        sql_update_seller = "UPDATE person SET money = money + %s WHERE username = %s"
        cursor.execute(sql_update_seller, (price, seller))

        # 更新买方的余额
        sql_update_buyer = "UPDATE person SET money = money - %s WHERE username = %s"
        cursor.execute(sql_update_buyer, (price, buyer))

        connection.commit()  # 提交事务
    except Exception as e:
        print("更新交易信息时发生错误！", e)
        connection.rollback()

    cursor.close()
    connection.close()




def new_judge():
    pass
def search_address(username):  # 查询账户地址
    connection = connect_to_database()
    cursor = connection.cursor()
    sql = "SELECT address FROM person WHERE username = (%s)"
    cursor.execute(sql, (username,))
    results = cursor.fetchall()
    cursor.close()
    connection.close()
    results = results[0][0]
    # print(results)
    return results



#主窗口
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(778, 739)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton_1 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_1.setGeometry(QtCore.QRect(340, 570, 101, 61))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.pushButton_1.setFont(font)
        self.pushButton_1.setObjectName("pushButton_1")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(90, 570, 101, 61))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setObjectName("pushButton_2")
        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser.setGeometry(QtCore.QRect(0, 10, 771, 81))
        self.textBrowser.setObjectName("textBrowser")
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setGeometry(QtCore.QRect(590, 570, 101, 61))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.pushButton_3.setFont(font)
        self.pushButton_3.setObjectName("pushButton_3")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(0, 90, 771, 601))
        self.label.setText("")
        self.label.setPixmap(QtGui.QPixmap("amain.png"))  # 导入背景图片
        self.label.setObjectName("label")
        self.textBrowser.raise_()
        self.label.raise_()
        self.pushButton_2.raise_()
        # self.pushButton_1.clicked.connect(self.authenticate)
        self.pushButton_1.raise_()
        self.pushButton_1.clicked.connect(self.show_login_dialog)  # 按钮一绑定登录跳转界面
        self.pushButton_3.raise_()
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 778, 23))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.retranslateUi(MainWindow)
        self.pushButton_3.clicked['bool'].connect(MainWindow.close)  # type: ignore
        self.pushButton_2.windowIconChanged['QIcon'].connect(self.statusbar.show)  # type: ignore
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton_1.setText(_translate("MainWindow", "登录"))
        self.pushButton_2.setText(_translate("MainWindow", "注册"))
        self.textBrowser.setHtml(_translate("MainWindow",
                                            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
                                            "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
                                            "p, li { white-space: pre-wrap; }\n"
                                            "</style></head><body style=\" font-family:\'SimSun\'; font-size:9pt; font-weight:400; font-style:normal;\">\n"
                                            "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:36pt; font-weight:600;\">  基于区块链的数据要素交易系统</span></p></body></html>"))
        self.pushButton_3.setText(_translate("MainWindow", "关闭"))
        self.pushButton_2.clicked.connect(self.show_register_dialog)  # 按钮二绑定注册界面

    def show_register_dialog(self):

        register_dialog = RegisterDialog()
        if register_dialog.exec_() == QtWidgets.QDialog.Accepted:
            # 如果用户成功注册，则在此处添加处理逻辑
            pass


    def show_login_dialog(self):  # 展示登录界面
        login_dialog = LoginDialog()  # 创建登录界面类对象
        if login_dialog.exec_() == QtWidgets.QDialog.Accepted:  # 使用 exec_() 方法显示对话框，该方法会阻塞程序的执行，直到用户关闭对话框。
            global username
            username = login_dialog.text_username.text()  # 如果用户在对话框中点击了"登录"按钮（即 exec_() 返回 QtWidgets.QDialog.Accepted），则获取用户在对话框中输入的用户名。
            global username_g
            username_g = username
            global address_g
            address_g = search_address(username)  # 调用 search_address 函数，通过数据库查询获取与该用户名相关联的地址，并将地址存储到全局变量 address_g 中。
            login_dialog.accept()  # 关闭登录对话框
            # 在匹配成功后，跳转到新的界面
            MainWindow.hide()
            print("进入综合服务系统\n")
            global serve_dlg  # !!!!!!!!!!!
            serve_dlg = ServeSystem()  # 创建“综合服务系统”界面类对象
            serve_dlg.show()


class RegisterDialog(QtWidgets.QDialog):
    def __init__(self):
        super(RegisterDialog, self).__init__()
        self.setWindowTitle("Register")
        self.resize(300, 250)

        layout = QtWidgets.QVBoxLayout()

        self.username_label = QtWidgets.QLabel("用户名:")
        self.username_input = QtWidgets.QLineEdit()
        layout.addWidget(self.username_label)
        layout.addWidget(self.username_input)

        self.password_label = QtWidgets.QLabel("密码:")
        self.password_input = QtWidgets.QLineEdit()
        self.password_input.setEchoMode(QtWidgets.QLineEdit.Password)
        layout.addWidget(self.password_label)
        layout.addWidget(self.password_input)

        self.email_label = QtWidgets.QLabel("邮箱:")
        self.email_input = QtWidgets.QLineEdit()
        layout.addWidget(self.email_label)
        layout.addWidget(self.email_input)

        self.address_label = QtWidgets.QLabel("地址:")
        self.address_input = QtWidgets.QLineEdit()
        layout.addWidget(self.address_label)
        layout.addWidget(self.address_input)

        self.private_key_label = QtWidgets.QLabel("私钥:")
        self.private_key_input = QtWidgets.QLineEdit()
        layout.addWidget(self.private_key_label)
        layout.addWidget(self.private_key_input)

        self.code_label = QtWidgets.QLabel("验证码:")
        self.code_input = QtWidgets.QLineEdit()
        layout.addWidget(self.code_label)
        layout.addWidget(self.code_input)
        # 设置按钮
        self.get_code_button = QtWidgets.QPushButton("获取验证码")
        layout.addWidget(self.get_code_button)
        self.get_code_button.clicked.connect(self.get_verification_code)
        layout.addWidget(self.code_input)

        self.register_button = QtWidgets.QPushButton("注册")
        layout.addWidget(self.register_button)
        self.register_button.clicked.connect(self.register)

        self.cancel_button = QtWidgets.QPushButton("取消")
        layout.addWidget(self.cancel_button)
        self.cancel_button.clicked.connect(self.cancel)

        self.setLayout(layout)

    def get_verification_code(self):  # 获取验证码
        email = self.email_input.text()
        if email == '':
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Please fill in email address")
        email_address = "http://127.0.0.1:5000/email"
        print(email_address)
        post_data = {'email': email}
        try:
            response = requests.post(email_address, json=post_data)  # 发送POST请求
            if response.status_code == 200:
                print("成功发送POST请求！")
                print("服务器响应:", response.json())
            else:
                print("发送POST请求失败！")
                return
        except requests.exceptions.RequestException as e:
            print("发送POST请求时出错:", e)
            return



    def register(self):
        # 获取输入框中的信息
        username = self.username_input.text()
        password = self.password_input.text()
        email = self.email_input.text()
        address = self.address_input.text()
        private_key = self.private_key_input.text()
        captcha = self.code_input.text()

        # 进行注册操作
        if self.validate_input(username, password, email, address, private_key, captcha):
            register_address = 'http://127.0.0.1:5000/register'
            userdata = {'username': username, 'password': password, 'email': email, 'address': address, 'private_key': private_key, 'captcha': captcha}
            try:
                response = requests.post(register_address, json=userdata)  # 发送POST请求
                if response.status_code == 200:
                    print("成功发送POST请求！")
                    print("服务器响应:", response.json())
                    QtWidgets.QMessageBox.information(self, "Registration Successful", "Registration successful!")

                else:
                    print(response.status_code)
                    print("发送POST请求失败！")
                    return
            except requests.exceptions.RequestException as e:
                print("发送POST请求时出错:", e)
                return
            # if self.insert_data(username, password, email, address, private_key):
            #     QtWidgets.QMessageBox.information(self, "Registration Successful", "Registration successful!")
            #     self.accept()  # 成功注册后关闭对话框
            # else:
            #     QtWidgets.QMessageBox.warning(self, "Error", "Failed to register. Please try again.")
        else:
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Please fill in all fields.")

    def cancel(self):
        self.reject()  # 取消注册，关闭对话框

    def validate_input(self, username, password, email, address, private_key, code):
        # 确保所有输入都不为空
        if not username or not password or not email or not address or not private_key or not code:
            return False
        return True

    def is_valid_address(self, address):
        if not Web3.isAddress(address):
            return False
        return True

    def is_valid_private_key(self, private_key):
        try:
            int(private_key, 16)
            return True
        except ValueError:
            return False

    def keys_match(self, public_key, private_key):
        w3 = Web3()
        account = w3.eth.account.from_key(private_key)
        derived_address = account.address
        return public_key.lower() == derived_address.lower()


    def insert_data(self, username, password, email, address, private_key):
        try:
            # 首先验证公钥和私钥是否匹配
            if not self.keys_match(address, private_key):
                QtWidgets.QMessageBox.warning(self, "Error", "Address and private key do not match!")
                return False
            # 连接数据库
            connection = connect_to_database()
            cursor = connection.cursor()
            # one：向 person 表中插入用户名和密码
            # sql_person = "INSERT INTO person (username,address, password) VALUES (%s, %s, %s)"
            # cursor.execute(sql_person, (username, address, password))
            # two：加入money的代码部分，没加使用上面的one部分 向 person 表中插入用户名和密码
            money = 0.00
            sql_person = "INSERT INTO person (username,address, password, money) VALUES (%s, %s, %s ,%s)"
            cursor.execute(sql_person, (username, address, password, money))

            # 向 person_address 表中插入地址和私钥
            sql_address = "INSERT INTO person_address (username , public_key, private_key) VALUES (%s, %s, %s)"
            cursor.execute(sql_address, (username ,address, private_key))

            # 提交更改
            connection.commit()
            cursor.close()

            # 如果提交更改成功，则返回 True
            return True
        except Exception as e:
            # 如果出现异常，则打印错误信息并返回 False
            print("Error:", e)
            return False


class LoginDialog(QtWidgets.QDialog):  # 登录
    def __init__(self):
        super(LoginDialog, self).__init__()
        self.setWindowTitle("用户登录")
        # self.setGeometry(100, 100, 300, 150)
        # 获取屏幕的宽度和高度
        screen_geometry = QDesktopWidget().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        # 设置对话框的初始大小
        dialog_width, dialog_height = 300, 150
        self.setGeometry((screen_width - dialog_width) // 2, (screen_height - dialog_height) // 2, dialog_width,
                         dialog_height)
        self.label_username = QtWidgets.QLabel("用户名:")
        self.label_password = QtWidgets.QLabel("密码:")
        self.text_username = QtWidgets.QLineEdit()
        self.text_password = QtWidgets.QLineEdit()
        self.text_password.setEchoMode(QtWidgets.QLineEdit.Password)
        self.button_login = QtWidgets.QPushButton("登录")
        self.button_login.clicked.connect(self.authenticate)  # 绑定登录事件
        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.label_username)
        layout.addWidget(self.text_username)
        layout.addWidget(self.label_password)
        layout.addWidget(self.text_password)
        layout.addWidget(self.button_login)
        self.setLayout(layout)

    def authenticate(self):  # 更新登陆方式，发送http请求
        global username
        username = self.text_username.text()
        password = self.text_password.text()
        print(password)
        login_address = "http://127.0.0.1:5000/login"
        if not username or not password:
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Please fill in all fields.")
            return
        try:
            userdata = {'username': username, "pwd": password}
            response = requests.post(login_address, json=userdata)  # 发送POST请求
            if response.status_code == 200:
                print("成功发送POST请求！")
                print("服务器响应:", response.json())
                QtWidgets.QMessageBox.information(self, "Login Successful", "Login successful!")
                self.hide()
                global serve_dlg  # !!!!!!!!!!!
                serve_dlg = ServeSystem()  # 创建“综合服务系统”界面类对象
                serve_dlg.show()


            else:
                message = response.json()
                print(message['error'])
                print(response.status_code)
                print("发送POST请求失败！")
                return
        except requests.exceptions.RequestException as e:
            print("发送POST请求时出错:", e)
            return


class ServeSystem(QMainWindow):  # 综合服务界面
    def __init__(self):
        super(ServeSystem, self).__init__()
        self.setWindowTitle("综合服务系统")
        self.setGeometry(100, 100, 600, 300)
        self.center_on_screen()  # 居中显示
        # 添加背景图片
        background_label = QLabel(self)
        background_pixmap = QtGui.QPixmap("amain.png")  # 替换成你的背景图片路径
        background_label.setPixmap(background_pixmap)
        background_label.setGeometry(0, 0, self.width(), self.height())
        # 添加按钮
        self.btn_buy = QPushButton("购买商品", self)
        self.btn_sell = QPushButton("出售商品", self)
        self.btn_view_account = QPushButton("查看账户信息", self)
        self.btn_arbitration = QPushButton("仲裁", self)  # 添加仲裁按钮
        # 一级窗口：余额，
        self.btn_return = QPushButton("返回", self)
        # 设置按钮的位置
        self.btn_buy.setGeometry(50, 50, 150, 40)
        self.btn_sell.setGeometry(50, 100, 150, 40)
        self.btn_view_account.setGeometry(50, 150, 150, 40)
        self.btn_arbitration.setGeometry(50, 200, 150, 40)  # 设置仲裁按钮的位置
        self.btn_return.setGeometry(50, 250, 150, 40)  # 设置返回按钮的位置

        # 连接按钮的槽函数
        self.btn_buy.clicked.connect(self.on_buy_clicked)
        self.btn_sell.clicked.connect(self.on_sell_clicked)
        self.btn_view_account.clicked.connect(self.on_view_account_clicked)
        self.btn_arbitration.clicked.connect(self.on_arbitration_clicked)  # 连接仲裁按钮的槽函数
        self.btn_return.clicked.connect(self.on_return_clicked)  # 连接返回按钮的槽函数

    def center_on_screen(self):
        screen_geometry = QApplication.desktop().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())

    def on_buy_clicked(self):
        self.hide()
        global buyer_dlg
        buyer_dlg = BuyerSystem()
        buyer_dlg.show()

    def on_sell_clicked(self):  # 进入卖家端
        self.hide()
        global seller_dlg
        seller_dlg = SellerSystem()
        seller_dlg.show()

    def on_view_account_clicked(self):
        self.hide()
        global account_info_window
        account_info_window = AccountInfoWindow()
        account_info_window.show()

    def on_arbitration_clicked(self):
        self.hide()
        global arbitration_window
        arbitration_window = ArbitrationWindow()
        arbitration_window.show()

    def on_return_clicked(self):
        self.hide()
        MainWindow.show()  # 返回登录界面


####################################################################################################################################################
# 用户余额界面
class UserInfoDialog(QMainWindow):
    def __init__(self, parent=None):
        super(UserInfoDialog, self).__init__(parent)
        self.setWindowTitle("用户信息")
        self.setFixedSize(600, 300)

        central_widget = QWidget()  # 创建一个中央部件
        self.setCentralWidget(central_widget)  # 将中央部件设置为窗口的主部件
        layout = QVBoxLayout(central_widget)  # 在中央部件上使用垂直布局

        self.username_label = QLabel()
        self.money_label = QLabel()

        layout.addWidget(self.username_label)
        layout.addWidget(self.money_label)

        # 添加返回按钮
        return_button_layout = QHBoxLayout()
        self.btn_return = QPushButton("返回", self)
        self.btn_return.clicked.connect(self.return_to_account_info)
        return_button_layout.addStretch(1)
        return_button_layout.addWidget(self.btn_return)
        layout.addLayout(return_button_layout)

        self.update_info("Default User", 0)  # 默认用户信息

    # 更新用户信息
    def update_info(self, username, money):
        self.username_label.setText(f"用户名: {username}")
        self.money_label.setText(f"账户金额: {money} 元")

    def return_to_account_info(self):
        self.close()
        # 这里需要将 AccountInfoWindow 替换为正确的窗口类
        global account_system
        account_system = AccountInfoWindow()
        account_system.show()


# 本卖家上架的商品列表
class ProductListPageMine(QMainWindow):
    def center_on_screen(self):
        screen_geometry = QDesktopWidget().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())


    def load_product_info(self):
        connection = connect_to_database()
        cursor = connection.cursor()
        sql="SELECT owner, name, size, time, good_hash, price, Key_Word FROM goods_information WHERE isForsale = 'yes' ANd owner=%s"
        cursor.execute(sql, (str(username[0]),))
        products = cursor.fetchall()
        cursor.close()

        # 创建表格窗口部件
        self.table_widget = QTableWidget(self.central_widget)
        self.layout.addWidget(self.table_widget)

        # 设置表格列数和列标题
        self.table_widget.setColumnCount(7)
        headers = ["所有者", "名称", "大小", "上架时间", "哈希", "价格", "关键字"]
        self.table_widget.setHorizontalHeaderLabels(headers)

        # 根据产品数量设置表格行数
        self.table_widget.setRowCount(len(products))

        # 用产品信息填充表格
        for row, product in enumerate(products):
            for col, item in enumerate(product):
                self.table_widget.setItem(row, col, QTableWidgetItem(str(item)))


    def sort_products(self, attribute, ascending):
        connection = connect_to_database()
        cursor = connection.cursor()
        sort_order = "ASC" if ascending else "DESC"
        cursor.execute(
            f"SELECT owner, name, size, time, good_hash, price, Key_Word FROM goods_information WHERE isForsale = 'yes' ORDER BY {attribute} {sort_order}")
        sorted_products = cursor.fetchall()
        cursor.close()

        # 清空表格
        self.table_widget.clearContents()

        # 填充排序后的产品信息
        for row, product in enumerate(sorted_products):
            for col, item in enumerate(product):
                self.table_widget.setItem(row, col, QTableWidgetItem(str(item)))


    def show_sort_options(self):
        msg = QMessageBox(self)
        msg.setWindowTitle("排序选项")
        msg.setText("请选择排序方式：")

        name_button = QRadioButton("商品名称")
        name_button.clicked.connect(lambda: self.show_order_options("name"))
        msg.addButton(name_button, QMessageBox.ActionRole)

        price_button = QRadioButton("价格")
        price_button.clicked.connect(lambda: self.show_order_options("price"))
        msg.addButton(price_button, QMessageBox.ActionRole)

        hash_button = QRadioButton("哈希值")
        hash_button.clicked.connect(lambda: self.show_order_options("good_hash"))
        msg.addButton(hash_button, QMessageBox.ActionRole)

        msg.exec_()

    def show_order_options(self, attribute):
        msg = QMessageBox(self)
        msg.setWindowTitle("排序选项")
        msg.setText("请选择排序方式：")

        ascending_button = QPushButton("升序")
        ascending_button.clicked.connect(lambda: self.sort_products(attribute, True))
        msg.addButton(ascending_button, QMessageBox.ActionRole)

        descending_button = QPushButton("降序")
        descending_button.clicked.connect(lambda: self.sort_products(attribute, False))
        msg.addButton(descending_button, QMessageBox.ActionRole)

        msg.exec_()

    def return_to_main(self):
        # 关闭商品列表界面
        self.close()
        global buyer_system
        buyer_system = BuyerSystem()
        buyer_system.show()


    def __init__(self):
        super(ProductListPageMine, self).__init__()
        self.setWindowTitle("商品列表")
        self.setGeometry(100, 100, 1000, 500)
        self.center_on_screen()  # 在屏幕中央显示窗口

        # 中央窗口部件和布局
        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)
        self.load_product_info()  # 加载商品信息

        # 添加排序按钮
        self.sort_button = QPushButton("排序", self)
        self.sort_button.setFont(QFont("Arial", 12))
        self.sort_button.setGeometry(400, 450, 200, 40)
        self.sort_button.clicked.connect(self.show_sort_options)

        # 添加返回按钮
        self.return_button = QPushButton("返回", self)
        self.return_button.setFont(QFont("Arial", 12))
        self.return_button.setGeometry(800, 450, 100, 40)
        self.return_button.clicked.connect(self.return_to_main)


# 账户信息界面
class AccountInfoWindow(QMainWindow):  # 账户信息窗口
    def __init__(self):
        super(AccountInfoWindow, self).__init__()
        self.setWindowTitle("账户信息")
        self.setGeometry(100, 100, 600, 300)
        self.center_on_screen()

        self.btn_query_balance = QPushButton("查询用户金额", self)
        self.btn_query_products = QPushButton("我已上架的商品", self)
        self.btn_query_transactions = QPushButton("交易记录", self)
        self.btn_return = QPushButton("返回", self)

        self.btn_query_balance.setGeometry(50, 50, 150, 40)
        self.btn_query_products.setGeometry(50, 100, 150, 40)
        self.btn_query_transactions.setGeometry(50, 150, 150, 40)
        self.btn_return.setGeometry(50, 200, 150, 40)

        self.btn_query_balance.clicked.connect(self.show_user_info)
        self.btn_query_products.clicked.connect(self.query_products)
        self.btn_query_transactions.clicked.connect(self.query_transactions)
        self.btn_return.clicked.connect(self.return_to_main)


        self.user_info_dialog = UserInfoDialog(self)

    def center_on_screen(self):
        screen_geometry = QApplication.desktop().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())



    def show_user_info(self):
        self.close()
        connection = connect_to_database()
        cursor = connection.cursor()
        sql = "SELECT money FROM person WHERE username=%s"
        cursor.execute(sql, username_g)
        money = cursor.fetchone()
        self.user_info_dialog.update_info(username_g, str(money[0]))
        self.user_info_dialog.show()  # 显示用户信息对话框



    def query_products(self):
        pass
        # self.close()  # 关闭当前窗口
        # global Mine_product_list_page
        # Mine_product_list_page = ProductListPageMine()
        # Mine_product_list_page.show()

    def query_transactions(self):
        self.close()  # 关闭当前窗口
        connection = connect_to_database()
        cursor = connection.cursor()
        sql = "SELECT seller, buyer, good_name, time, price, tradehash FROM transcation WHERE seller=(%s) OR buyer=(%s)"
        cursor.execute(sql, (username_g, username_g))
        transactions = cursor.fetchall()
        table_widget = QTableWidget()
        table_widget.setRowCount(len(transactions))
        table_widget.setColumnCount(6)
        table_widget.setHorizontalHeaderLabels(["Seller", "Buyer", "Good Name", "Time", "Price", "Tradehash"])

        for row, transaction in enumerate(transactions):
            for col, value in enumerate(transaction):
                item = QTableWidgetItem(str(value))
                table_widget.setItem(row, col, item)

        layout = QVBoxLayout()
        layout.addWidget(table_widget)

        widget = QWidget()
        widget.setLayout(layout)
        self.setCentralWidget(widget)
        self.show()  # 确保窗口显示

    def return_to_main(self):
        self.close()
        serve_dlg.show()

    def return_to_main(self):
        self.close()
        serve_dlg.show()  # 这里假设 serve_dlg 是你的主界面窗口对象

# 自定义输入框
class ProductInfoDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("设置商品信息")
        layout = QVBoxLayout(self)
        self.price_line_edit = QLineEdit()
        self.name_line_edit = QLineEdit()
        layout.addWidget(QLabel("价格:"))
        layout.addWidget(self.price_line_edit)
        layout.addWidget(QLabel("名称:"))
        layout.addWidget(self.name_line_edit)
        self.buttons_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttons_box.accepted.connect(self.accept)
        self.buttons_box.rejected.connect(self.reject)
        layout.addWidget(self.buttons_box)

    def add_line_edits(self):
        attributes = ["价格", "名称"]
        for attribute in attributes:
            label = QLabel(attribute)
            line_edit = QLineEdit()
            self.layout.addWidget(label)
            self.layout.addWidget(line_edit)
            self.line_edits.append(line_edit)

    def get_product_info(self):  # 返回输入的信息
        return self.price_line_edit.text(), self.name_line_edit.text()


class SellerSystem(QMainWindow):  # 卖家界面
    def __init__(self):
        super(SellerSystem, self).__init__()
        self.setWindowTitle("卖家界面")
        self.setGeometry(100, 100, 600, 300)
        self.center_on_screen()  # 居中显示
        # 添加背景图片
        background_label = QLabel(self)
        background_pixmap = QtGui.QPixmap("amain.png")  # 替换成你的背景图片路径
        background_label.setPixmap(background_pixmap)
        background_label.setGeometry(0, 0, self.width(), self.height())
        # 添加按钮
        self.btn_select_file = QPushButton("选择文件", self)
        self.btn_encrypt_upload = QPushButton("加密并上传文件", self)
        self.btn_set_product_info = QPushButton("设置商品信息", self)
        self.textbox_file_path = QLineEdit(self)  # 添加文本框
        self.btn_return = QPushButton("返回", self)

        self.textbox_file_path = QLineEdit(self)  # 添加文本框
        # 设置按钮的位置
        self.btn_select_file.setGeometry(50, 50, 150, 40)
        self.btn_encrypt_upload.setGeometry(50, 100, 150, 40)
        self.btn_return.setGeometry(50, 200, 150, 40)  # 设置返回按钮的位置
        self.btn_set_product_info.setGeometry(50, 150, 150, 40)  # 设置设置商品信息按钮的位置

        self.textbox_file_path.setGeometry(210, 50, 300, 40)  # 设置文本框位置
        # 连接按钮的槽函数
        self.btn_select_file.clicked.connect(self.on_select_file_clicked)
        self.btn_encrypt_upload.clicked.connect(self.on_encrypt_upload_clicked)
        self.btn_set_product_info.clicked.connect(self.on_set_product_info_clicked)  # 连接设置商品信息按钮的槽函数
        self.btn_return.clicked.connect(self.on_return_clicked)  # 连接返回按钮的槽函数
        self.filepath = None
        self.owner = None
        self.size = None
        self.price = 0.00
        self.name = None

    def center_on_screen(self):
        screen_geometry = QDesktopWidget().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())

    def on_set_product_info_clicked(self):
        dialog = ProductInfoDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            price, name = dialog.get_product_info()  # ！进行类型判别，防止输入与数据库属性不匹配的数据
            try:
                price = float(price)  # 使用try，except结构来判断，防止出现错误输入
            except ValueError:
                QMessageBox.warning(self, "错误", "价格必须是数值型变量！")
                return
                # 对名称进行类型检查
            if not isinstance(name, str):
                QMessageBox.warning(self, "错误", "名称必须是字符串型变量！")
                return
            print("价格:", price)
            print("名称:", name)
            self.name = name
            self.price = price

    def on_select_file_clicked(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        file_name, _ = QFileDialog.getOpenFileName(self, "选择文件", "", "All Files (*)",
                                                   options=options)  # 使用QFileDialog打开文件对话框，获取用户选择的文件路径file_name
        if file_name:
            self.filepath = file_name
            # 将文件路径显示在界面上的文本框中
            self.textbox_file_path.setText(self.filepath)

    def on_encrypt_upload_clicked(self):
        File_Path = self.filepath
        price = self.price
        name = self.name
        if not File_Path:
            QMessageBox.warning(self, "提示", "请先选择文件！")
            return
        if (name is None) or (price is None):
            QMessageBox.warning(self, "错误", "请输入商品名称与价格！")
            return
        filesize = os.path.getsize(self.filepath)  # 获取文件大小
        CryptTest.create_rsa_key()  # 创建非对称加密密钥对
        CryptTest.encrypt_oracle(File_Path)  # 加密所选择的文件，同时加密AES密钥
        # 导入密文存放路径
        savepath = "savepath.txt"
        with open(savepath, 'r') as file:
            file_content = file.read()
        savepath = file_content
        print(f"密文存放路径为：{savepath}\n")
        print(username)
        private_key_path = "private_a.pem"  # RSA私钥路径
        all1.CreateMerkleTree(savepath)  # 生成密文的默克尔树
        MerkleTree_path = "Merkle1_Tree.txt"  # 密文默克尔树的路径
        # 密文上传到IPFS(需先启动go-ipfs服务)
        client = ipfshttpclient.connect('/ip4/127.0.0.1/tcp/5001/http')
        file_hash = client.add(savepath)['Hash']  # 上传密文，并获取密文的hash地址
        pkey_hash = client.add(private_key_path)['Hash']  # 上传RSA公钥， 并获取其hash地址
        key_hash = client.add("KEY")['Hash']  # 上传AES密钥， 并获取其hash地址
        MerkleTree_hash = client.add(MerkleTree_path)['Hash']  # 上传密文默克尔树，并获取其hash地址
        # print(f"{file_hash}")
        id = SmartContract1.get_id_num() + 1  # 在当前库中最大id基础上+1，作为本次上传商品的id
        new_goods(username, filesize, file_hash, price, name, id, pkey_hash, key_hash, MerkleTree_hash)  # 上传新的商品信息到数据库
        # 在智能合约中上架：
        price_in_wei = int(price * 10 ** 18)  # 将价格转换为wei类型
        SmartContract1.upload_blockchain_video_onsale(From, key_hash, price_in_wei, pkey_hash)  # 上架AES密钥地址，价格，RSA密钥地址


    def on_return_clicked(self):
        self.close()
        serve_dlg.show()  # 返回综合服务系统界面


# 总商品列表
class ProductListPage(QMainWindow):

    def __init__(self):  # 设置商品列表界面
        super(ProductListPage, self).__init__()
        self.setWindowTitle("商品列表")
        self.setGeometry(100, 100, 1000, 500)
        self.center_on_screen()  # 在屏幕中央显示窗口

        # 中央窗口部件和布局
        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)
        self.load_product_info()  # 加载商品信息

        # 添加购买按钮
        self.buy_button = QPushButton("购买", self)
        self.buy_button.setFont(QFont("Arial", 12))
        self.buy_button.setGeometry(100, 450, 100, 40)
        self.buy_button.clicked.connect(self.buy_goods)  # 点击后触发对应购买函数
        # 添加排序按钮
        self.sort_button = QPushButton("排序", self)
        self.sort_button.setFont(QFont("Arial", 12))  # 将按钮的字体设置为 Arial 字体，字号为 12。
        self.sort_button.setGeometry(400, 450, 200, 40)
        self.sort_button.clicked.connect(self.show_sort_options)

        # 添加返回按钮
        self.return_button = QPushButton("返回", self)
        self.return_button.setFont(QFont("Arial", 12))
        self.return_button.setGeometry(800, 450, 100, 40)
        self.return_button.clicked.connect(self.return_to_main)
        self.id = -1
        self.seller = None

    def center_on_screen(self):
        screen_geometry = QDesktopWidget().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())

    def select_row_and_return_id(self, row, column):
        # 获取双击的单元格id数据
        item = self.table_widget.item(row, 7)  # 获取id值所在的列（索引为7）
        seller = self.table_widget.item(row, 1)  # 获取owner所在的列
        if (item is not None) and (seller is not None):
            id_num = item.text()  # 获取id
            seller_name = seller.text()
            print("选中的id值为:", id_num)
            self.id = id_num
            self.seller = seller_name
            return id_num


    def load_product_info(self):
        connection = connect_to_database()
        cursor = connection.cursor()
        cursor.execute(
            "SELECT owner, name, size, time, good_hash, price, Key_Word, id FROM goods_information WHERE isForsale = 'yes'")
        products = cursor.fetchall()
        cursor.close()

        # 创建表格窗口部件
        self.table_widget = QTableWidget(self.central_widget)
        self.layout.addWidget(self.table_widget)

        # 设置表格列数和列标题
        self.table_widget.setColumnCount(8)
        headers = ["所有者", "名称", "大小", "上架时间", "商品地址哈希", "价格", "关键字","商品ID"]
        self.table_widget.setHorizontalHeaderLabels(headers)

        # 根据产品数量设置表格行数
        self.table_widget.setRowCount(len(products))
        self.table_widget.cellDoubleClicked.connect(self.select_row_and_return_id)  # 双击触发相应函数

        # 用产品信息填充表格
        for row, product in enumerate(products):
            for col, item in enumerate(product):
                self.table_widget.setItem(row, col, QTableWidgetItem(str(item)))


    def sort_products(self, attribute, ascending):
        connection = connect_to_database()
        cursor = connection.cursor()
        sort_order = "ASC" if ascending else "DESC"
        cursor.execute(
            f"SELECT owner, name, size, time, good_hash, price, Key_Word FROM goods_information WHERE isForsale = 'yes' ORDER BY {attribute} {sort_order}")
        sorted_products = cursor.fetchall()
        cursor.close()

        # 清空表格
        self.table_widget.clearContents()

        # 填充排序后的产品信息
        for row, product in enumerate(sorted_products):
            for col, item in enumerate(product):
                self.table_widget.setItem(row, col, QTableWidgetItem(str(item)))


    def show_sort_options(self):
        msg = QMessageBox(self)
        msg.setWindowTitle("排序选项")
        msg.setText("请选择排序方式：")

        name_button = QRadioButton("商品名称")
        name_button.clicked.connect(lambda: self.show_order_options("name"))
        msg.addButton(name_button, QMessageBox.ActionRole)

        price_button = QRadioButton("价格")
        price_button.clicked.connect(lambda: self.show_order_options("price"))
        msg.addButton(price_button, QMessageBox.ActionRole)

        hash_button = QRadioButton("哈希值")
        hash_button.clicked.connect(lambda: self.show_order_options("good_hash"))
        msg.addButton(hash_button, QMessageBox.ActionRole)

        msg.exec_()

    def show_order_options(self, attribute):
        msg = QMessageBox(self)
        msg.setWindowTitle("排序选项")
        msg.setText("请选择排序方式：")

        ascending_button = QPushButton("升序")
        ascending_button.clicked.connect(lambda: self.sort_products(attribute, True))
        msg.addButton(ascending_button, QMessageBox.ActionRole)

        descending_button = QPushButton("降序")
        descending_button.clicked.connect(lambda: self.sort_products(attribute, False))
        msg.addButton(descending_button, QMessageBox.ActionRole)

        msg.exec_()

    def buy_goods(self):
        goods_id = self.id  # 获取商品id
        goods_id = int(goods_id)
        if goods_id == -1:
            print("错误")
            QtWidgets.QMessageBox.warning(self, "错误", "商品id不存在")
            return
        SmartContract1.getTrade(From, goods_id)  # 执行交易
        connection = connect_to_database()
        cursor = connection.cursor()
        sql = "SELECT owner, name ,price FROM goods_information WHERE id = (%s)"
        cursor.execute(sql,(goods_id))
        info = cursor.fetchall()  # 获取元组
        seller = info[0][0] # 获取信息
        name = info[0][1]
        price = info[0][2]
        trade_hash = SmartContract1.getTX_HASH()
        new_transcations(seller, From, name, price, trade_hash)  # 更新交易记录



    def return_to_main(self):
        # 关闭商品列表界面
        self.close()
        global buyer_system
        buyer_system = BuyerSystem()
        buyer_system.show()






# 买家界面
class BuyerSystem(QMainWindow):  # 买家界面
    def __init__(self):
        super(BuyerSystem, self).__init__()
        self.setWindowTitle("买家界面")
        self.setGeometry(100, 100, 600, 300)
        self.center_on_screen()  # 居中显示
        # 添加背景图片
        background_label = QLabel(self)
        background_pixmap = QtGui.QPixmap("amain.png")  # 替换成你的背景图片路径
        background_label.setPixmap(background_pixmap)
        background_label.setGeometry(0, 0, self.width(), self.height())
        # 添加按钮
        self.btn_view_products = QPushButton("查看商品列表", self)
        #self.btn_purchase = QPushButton("购买商品", self)
        self.btn_decrypt_file = QPushButton("解密文件", self)  # 新添加的按钮
        self.btn_return = QPushButton("返回", self)
        # self.textbox_file_path = QLineEdit(self)  # 添加文本框
        # 设置按钮的位置
        self.btn_view_products.setGeometry(50, 50, 150, 40)
        #self.btn_purchase.setGeometry(50, 100, 150, 40)  # 设置购买商品按钮（未启用）
        self.btn_decrypt_file.setGeometry(50, 150, 150, 40)  # 设置按钮的位置
        self.btn_return.setGeometry(50, 200, 150, 40)  # 设置返回按钮的位置
        # self.textbox_file_path.setGeometry(210, 150, 300, 40)  # 设置文本框位置

        # 连接按钮的槽函数
        self.btn_view_products.clicked.connect(self.on_view_products_clicked)
        #self.btn_purchase.clicked.connect(self.on_purchase_clicked)
        self.btn_decrypt_file.clicked.connect(self.on_decrypt_file_clicked)  # 连接解密文件按钮的槽函数
        self.btn_return.clicked.connect(self.on_return_clicked)  # 连接返回按钮的槽函数

    def center_on_screen(self):
        screen_geometry = QDesktopWidget().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())

    def on_view_products_clicked(self):
        print("查看商品列表按钮被点击")
        # 关闭当前界面
        self.close()
        # 显示商品列表界面
        global product_list_page
        product_list_page = ProductListPage()
        product_list_page.show()

    def on_purchase_clicked(self):
        # print("购买商品按钮被点击")

        def center_on_screen(self):
            screen_geometry = QDesktopWidget().screenGeometry()
            screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
            self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                             self.width(), self.height())

        def on_select_file_clicked(self):
            print("选择文件按钮被点击")

        def on_select_key_clicked(self):
            print("选择密钥按钮被点击")

        def on_start_decrypt_clicked(self):
            print("开始解密按钮被点击")

    def on_decrypt_file_clicked(self):
        print("解密文件按钮被点击")
        self.close()
        global decrypt_file_page
        decrypt_file_page = DecryptFilePage()
        decrypt_file_page.show()

    def on_return_clicked(self):
        self.hide()
        serve_dlg.show()



class DecryptFilePage(QMainWindow):  # 二级窗口,解密文件
    def __init__(self):
        super(DecryptFilePage, self).__init__()
        self.setWindowTitle("解密文件界面")
        self.setGeometry(100, 100, 600, 300)
        self.center_on_screen()

        # 添加背景图片
        background_label = QLabel(self)
        background_pixmap = QtGui.QPixmap("amain.png")
        background_label.setPixmap(background_pixmap)
        background_label.setGeometry(0, 0, self.width(), self.height())
        self.textbox_file_path1 = QLineEdit(self)  # 添加文本框
        self.textbox_file_path2 = QLineEdit(self)
        # 添加按钮
        self.btn_select_file = QPushButton("选择文件", self)
        self.btn_select_key = QPushButton("选择密钥（RSA私钥）", self)
        self.btn_start_decrypt = QPushButton("开始解密", self)
        self.btn_return = QPushButton("返回", self)
        # 设置按钮的位置
        self.btn_select_file.setGeometry(50, 50, 150, 40)
        self.btn_select_key.setGeometry(50, 100, 150, 40)
        self.btn_start_decrypt.setGeometry(50, 150, 150, 40)
        self.btn_return.setGeometry(50, 200, 150, 40)
        # 设置文本框位置
        self.textbox_file_path1.setGeometry(210, 50, 300, 40)
        self.textbox_file_path2.setGeometry(210, 100, 300, 40)
        # 连接按钮的槽函数
        self.btn_select_file.clicked.connect(self.on_select_file_clicked)
        self.btn_select_key.clicked.connect(self.on_select_key_clicked)
        self.btn_start_decrypt.clicked.connect(self.on_start_decrypt_clicked)
        self.btn_return.clicked.connect(self.on_return_clicked)
        self.de_crypt_keyname = None  # 密钥路径
        self.de_crypt_filename = None  # 密文路径

    def center_on_screen(self):
        screen_geometry = QDesktopWidget().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())

    def on_select_file_clicked(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        file_name, _ = QFileDialog.getOpenFileName(self, "选择文件", "", "All Files (*)",
                                                   options=options)  # 使用QFileDialog打开文件对话框，获取用户选择的文件路径file_name
        if file_name:
            self.de_crypt_filename = file_name
            print(f"选择的文件路径: {self.de_crypt_filename}")
            # 将文件路径显示在界面上的文本框中
            self.textbox_file_path1.setText(self.de_crypt_filename)

    def on_select_key_clicked(self):
        # print("选择密钥按钮被点击")
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        file_name, _ = QFileDialog.getOpenFileName(self, "选择文件", "", "All Files (*)",
                                                   options=options)  # 使用QFileDialog打开文件对话框，获取用户选择的密钥文件路径file_name
        if file_name:
            self.de_crypt_keyname = file_name
            print(f"选择的文件路径: {self.de_crypt_keyname}")
            # 将文件路径显示在界面上的文本框中
            self.textbox_file_path2.setText(self.de_crypt_keyname)

    def on_start_decrypt_clicked(self):  # 进行文件解密
        print("开始解密按钮被点击")
        key_path = self.de_crypt_keyname  # RSA私钥的文件
        file_path = self.de_crypt_filename
        CryptTest.decrypt_oralce(file_path, key_path)
        # 添加解密成功与失败的弹窗

    def on_return_clicked(self):
        self.hide()
        global buyer_system
        buyer_system = BuyerSystem()
        buyer_system.show() # 返回买家界面



class ArbitrationWindow(QMainWindow):  # 仲裁界面
    def __init__(self):
        super(ArbitrationWindow, self).__init__()
        self.setWindowTitle("仲裁界面")
        self.setGeometry(100, 100, 400, 200)
        self.center_on_screen()  # 居中显示

        # 添加按钮和输入框
        self.btn_choose_buyer_tree = QPushButton("选择买家树文件", self)
        self.btn_choose_seller_tree = QPushButton("选择卖家树文件", self)
        self.btn_compare_trees = QPushButton("对比两树", self)
        self.btn_return = QPushButton("返回", self)
        self.input_buyer_tree_path = QLineEdit(self)
        self.input_seller_tree_path = QLineEdit(self)

        # 设置位置
        self.input_buyer_tree_path.setGeometry(200, 50, 150, 30)
        self.input_seller_tree_path.setGeometry(200, 100, 150, 30)
        self.btn_choose_buyer_tree.setGeometry(50, 50, 130, 30)
        self.btn_choose_seller_tree.setGeometry(50, 100, 130, 30)
        self.btn_compare_trees.setGeometry(50, 150, 130, 30)
        self.btn_return.setGeometry(200, 150, 130, 30)

        # 连接按钮的槽函数
        self.btn_choose_buyer_tree.clicked.connect(self.choose_buyer_tree)
        self.btn_choose_seller_tree.clicked.connect(self.choose_seller_tree)
        self.btn_compare_trees.clicked.connect(self.compare_trees)
        self.btn_return.clicked.connect(self.return_to_main)

    def center_on_screen(self):
        screen_geometry = QApplication.desktop().screenGeometry()
        screen_width, screen_height = screen_geometry.width(), screen_geometry.height()
        self.setGeometry((screen_width - self.width()) // 2, (screen_height - self.height()) // 2,
                         self.width(), self.height())

    def choose_buyer_tree(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "选择买家树文件", "", "All Files (*)")
        if file_path:
            self.input_buyer_tree_path.setText(file_path)

    def choose_seller_tree(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "选择卖家树文件", "", "All Files (*)")
        if file_path:
            self.input_seller_tree_path.setText(file_path)

    def compare_trees(self):
        # 获取文件路径
        buyer_tree_file = self.input_buyer_tree_path.text()
        seller_tree_file = self.input_seller_tree_path.text()

        # 读取默克尔树
        merkle_tree1 = read_merkle_tree_from_file(buyer_tree_file)
        merkle_tree2 = read_merkle_tree_from_file(seller_tree_file)

        # 对比两颗树
        different_nodes = compare_merkle_trees(merkle_tree1, merkle_tree2)

        # 写入对比结果到文件
        with open("D:/king/Compare.txt", "w") as fp3:  # 修改为自己的地址
            flag = False
            for level in range(len(different_nodes)):
                if different_nodes[level]:
                    fp3.write(f"第{level}层：\n")
                    flag = True
                    for different_nodes_tuple in different_nodes[level]:
                        fp3.write(f"{different_nodes_tuple[0]} <--> {different_nodes_tuple[1]}\n")

            if flag==False:
                fp3.write("No differences found.\n")
                QtWidgets.QMessageBox.warning(self, "仲裁结束", "文件未被篡改")
            else:
                fp3.write(" differences found.\n")
                QtWidgets.QMessageBox.warning(self, "仲裁结束", "文件被篡改，仲裁结果已存储在D:/king/Compare.txt中")


        self.close()  # 关闭仲裁界面

    def return_to_main(self):
        self.close()
        serve_dlg.show()  # 返回综合服务系统界面



if __name__ == '__main__':
    import sys
    app = QApplication(sys.argv)
    MainWindow = QMainWindow()
    ui = Ui_MainWindow()  # 创建类对象
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
